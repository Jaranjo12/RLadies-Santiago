# Tutorial: primeros pasos en R

Tutorial en construcción del Taller organizado por [RLadies Santiago](https://meetup.com/rladies-scl) y realizado por [Riva Quiroga](https://twitter.com/rivaquiroga)


## Instalación de R y RStudio

En este taller utilizaremos R a través del IDE RStudio. ¿Qué es un IDE? IDE es el acrónimo de *Integrated Development Environment*, es decir, un *Entorno de Desarrollo Integrado*. Esto quiere decir que RStudio es una aplicación que nos entrega herramientas para hacer más fácil el desarrollo de proyectos usando R.  

Para poder instalar R y RStudio, sigue los siguientes pasos:

- Descarga R desde https://cran.r-project.org/. Debes elegir la opción que corresponda, según tu sistema operativo.
- Instala R en tu computador, tal como lo haces con cualquier programa. 
- Una vez que R ha quedado correctamente instalado, descarga RStudio desde https://www.rstudio.com/products/rstudio/download/. Elige la primera opción, es decir, "RStudio Desktop Open Source License" (gratuita). 
- Instala RStudio en tu computador, tal como lo haces con cualquier programa. 

Si quedó todo bien instalado, cuando abras RStudio deberías ver algo así:

![](https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio.png)

En este tutorial usaremos al última versión de R y RStudio, así que si tienes instalada una versión previa, puede que algunas cosas se vean un poco distintas.

Si te aparece algún error durante este proceso, lo más probabable es que sea por alguna configuración de tu sistema operativo. En ese caso, la mejor manera de buscar una solución es copiar el error que arroja R, pegarlo en tu motor de búsqueda favorito y ver cómo alguien que se enfrentó a eso antes lo resolvió. 

## Instalación de los paquetes de R que utilizaremos

Cuando instalamos R por primera vez en nuestro computador, lo que estamos instalando es lo que se conoce como "R Base", es decir, los elementos centrales del lenguaje de programación. Una de las ventajas de R es que se trata de un lenguaje extensible: la propia comunidad de usuarios puede desarrollar nuevas posibilidades para utilizarlo. La manera de compartir estos nuevos desarrollos es a través de "paquetes", que incluyen, entre otras cosas, código y datos.

En este taller usaremos tres paquetes: `gapminder`, `babynames` y `tidyverse`. Los dos primeros (`gapminder` y `babynames`) son paquetes de datos que nos servirán para algunos de los ejercicios que realizaremos. `tidyverse`, por su parte, es un "megapaquete" que incluye otros paquetes en su interior. Todos los paquetes que conforman el Tidyverse comparten la misma visión sobre el trabajo con datos. Quizás ahora eso suene un poco enigmático, pero más adelante explicaremos qué quiere decir. 

Para instalarlos, 

1. copia el siguiente código:

```r
install.packages("tidyverse")
install.packages("gapminder")
install.packages("babynames")
```

2. pégalo en la consola (_Console_) de RStudio:

![](https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/install.packages.png)

3. presiona 'enter'. 
El último paquete es un poco más pesado que el resto, así que, dependiendo de tu conexión, podría tomar un minuto. El resultado se debería ver parecido a esto:

![](https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/paquetes_instalados.png)

¿Salió todo bien? ¡Excelente! Ya escribiste tus primeras líneas de código :)

#### Advertencias / Warnings
Si no tienes la última versión de R, puede que aparezca un "Warning" al durante la instalación que avisa que el paquete fue construido bajo otra versión de R. Un "Warning" es distinto a un error: R ejecuta el código que le pides, pero te advierte que no todo puede resultar como esperas. 

## Utilización de RStudio

Como señalamos antes, RStudio es un entorno que facilita el trabajo con R. Si solo abres R en tu computador, lo que verás es una consola. Cuando trabajamos en ella escribimos directamente el código que queremos que se ejecute.

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/r_consola.png" align="center" height="400"></a>

Si abres RStudio verás que te aparece la misma consola, pero además te encontrarás con otros paneles. Estos paneles nos ayudan a organizar nuestro trabajo y hacen todo el proceso más sencillo. 

![](https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio.png)

¿Para qué sirven estos paneles? Comentemos primero el panel de abajo a la derecha. Si te fijas, el panel tiene varias ventanas: 

* __Files__ muestra el directorio (la carpeta) en la que te encuentras actualmente. En mi caso, no hay nada ahí porque por defecto RStudio me muestra el Escritorio (_Desktop_). Es posible que a ti te muestre otra carpeta (por ejemplo, _Documentos_). 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_files.png" align="center" height="300"></a>

* __Plots__ es el lugar donde aparecerán los gráficos que crees. No hemos hecho ninguno por ahora, así que este panel también está vacío. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_plots.png" align="center" height="300"></a>

* __Packages__ muestra la lista de paquetes que tienes instalados en tu computador. Si recorres el panel verás que algunos tiene una marca al lado izquierdo. Eso quiere decir que el paquete está activo en ese momento (ya veremos cómo hacer eso). Solo los paquetes vinculados a R base se activan al abrir RStudio. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_packages.png" align="center" height="300"></a>

* __Help__, como su nombre lo indica, es la pestaña en la que podemos encontrar ayuda. Si buscamos el nombre de un paquete o de una función, RStudio nos remitirá a la documentación asociada. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_help.png" align="center" height="300"></a>

* __Viewer__ es el panel para ver contenido web generado por algún paquete de R (gráficos para la web o aplicaciones interactivas). Por el momento no lo utilizaremos. 

El panel de arriba a la derecha, por su parte, contiene el historial de funciones que hemos ejecutado (_History_), la opción para generar conexiones a bases de datos externas (_Connections_) y _Environment_. Este último panel es muy importante y entender lo que nos muestra es fundamental para comprender cómo funciona R. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_globalenvironment.png" align="center" height="300"></a>

Por ahora está vacío porque no hemos creado ningún objeto o variable, pero cuando creemos alguno es aquí donde aparecerá. Ya volveremos a hablar sobre este panel cuando comenzemos a trabajar con datos. 

Hay un cuarto panel (que probablemente todavía no te aparece)  y que es el que utilizamos para escribir el código que queremos que R ejecute, es decir, el panel para nuestro _script_. Para crear un nuevo script podemos:
* ir a File > New File > R Script
* ocupar el atajo de teclado `comando` + `shift` + `n` (Mac) o `control` + `shift` + `n` (Linux / Windows)
* o seleccionar la opción desde la barra superior de la ventana:

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/nuevo_script.png" align="center" height="300"></a>

¡Ahora ya están los cuatro paneles!

[Nota: si alguna vez has utilizado Git o Github, lo que diré a continuación tendrá algo de sentido. Si no, puedes omitir este comentario y seguir 
Si te fijas, en el panel en que está la consola hay una segunda pestaña: el/la Terminal. Esto es muy útil, ya que, por ejemplo, si tu proyecto lo tienes alojado en Github, no tienes que salir de R para hacer commit a los cambios que has hecho].

### Creación de un proyecto 

Una de las ventajas de RStudio es que permite crear "proyectos". Un projecto es un espacio o contexto de trabajo asociado a una carpeta en particular, en la que se guardan nuestro(s) script(s), archivos, etc. Cuando creamos un proyecto en RStudio, se crea un tipo especial de archivo (.Rproj) que lo que hace es vincular todo lo que se encuentra dentro de esa carpeta. ¿Por qué esto es útil? Si parte de nuestro script, por ejemplo, implica abrir un archivo que está en la carpeta de nuestro proyecto, no necesito indicar en mi código toda la ruta del archivo: lo que hará RStudio será buscarlo en el entorno/carpeta del projecto. Esto es muy muy útil, ya que si movemos la carpeta a otro lugar de nuestro computador o la compartimos con otra persona, por ejemplo, nuestro código seguirá funcionando.

¿Cómo crear un projecto? Puedes hacerlo desde el menú File > New Proyect. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_newproject1.png" align="center" height="250"></a>

Lo primero que nos pregunta es si queremos crearlo en una carpeta nueva o en una ya existente. Elegiremos esta vez una carpeta nueva, así que seleccionaremos _New Directory_. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_newproject2.png" align="center" height="250"></a>

La siguiente pregunta es qué tipo de proyecto queremos crear. En esta ocasión, elegiremos la primera: _New Project_.

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_newproject3.png" align="center" height="250"></a>

Finalmente, le damos un nombre al proyecto y decidimos en qué parte de nuestro computador queremos que viva la carpeta que lo contiene. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_newproject4.png" align="center" height="250"></a>

Luego de apretar _Create Project_, RStudio se reinicia y se producen algunos cambios. El panel _Files_ (abajo a la derecha) ahora nos muestra la carpeta de nuestro proyecto y el único archivo que hay en ella por ahora. Ese es el archivo mágico que mantiene unido todo lo que hay dentro de la carpeta. Cuando queramos volver a trabajar en nuestro proyecto, solo tenemos que abrir ese archivo. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_rproj.png" align="center" height="150"></a>

Otro cambio que ocurre es que en la barra superior aparece ahora la ruta de la carpeta de nuestro projecto. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_barraproyecto.png" align="center" height="50"></a>

Por último, algo cambia en el ícono de R: aparece el nombre que le dimos a nuestro proyecto:

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/rstudio_icono.png" align="center" height="120"></a>


Esto último es muy muy muy útil: RStudio ejecuta sesiones independientes de R para cada proyecto. Es decir, si tuvieras otro proyecto abierto te aparecería otro ícono, con su respectivo nombre. Esto nos permite trabajar en dos proyectos en paralelo sin que se nos mezclen los objetos del entorno, el código, los archivos, etc. ¡Cada cosa en su lugar!

Ya tenemos todo listo para empezar :)

## Cargar los paquetes necesarios

Ya tenemos instalados los tres paquetes que ocuparemos en esta ocasión Cada vez que instalamos un paquete, esta queda en nuestro computador y podemos chequear eso revisando el panel "Packages" abajo a la izquierda. Sin embargo, que los hayamos instalado no quiere decir que estén listos para ser usados. Tenemos que decirle explícitamente a R qué paquetes queremos ocupar en cada sesión (no tiene sentido tener activos paquetes que no estamos utilizando).

La función para llamar o activar un paquete es `library(nombre_del_paquete)`, así que escribiremos eso al inicio de nuestro script. Si no tienes un script abierto, simplemente sigue los pasos comentados más arriba (File > New File > R Script).

RStudio trata de hacernos la vida más simple, así que cuando empezamos a escribir se despliega un menú con posibles opciones que indican el nombre de la función y el paquete al que está asociada (en este caso, sugiere `{base}`). Lo que aparece en amarillo es la estructura de la función, algo sobre lo que no hablaremos por ahora.

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/sugerencia_funcion.png" align="center" height="200"></a>

Lo mismo ocurre cuando empezamos a escribir el nombre del paquete. RStudio nos va ofreciendo sugerencias a partir de los paquetes que tenemos instalados: 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/sugerencia_argumento.png" align="center" height="200"></a>


Todavía no hemos 'ejecutado' el código, así que nada ha pasado. Como todo en R, hay varias opciones para hacer esto. 
Si hacemos clic en el botón _Run_ que está en la barra del script, se ejecutará la línea de código en la que está actualmente el cursor y este se moverá automáticamente a la siguiente línea. Es decir, si ponemos el curso en la línea en la que llamamos por primera vez la función `library`y hacemos clic tres veces, se ejecutarán las tres líneas. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/ejecutar_codigo.png" align="center" height="200"></a>

Eso mismo podemos hacerlo usando un atajo del teclado `ctrl` + `enter` (si estás en Linux o Windows) o `comando` + `enter` si estás en Mac. 

Cuando queremos ejecutar más de una línea de código, lo que podemos hacer es seleccionar todo el fragmento y hacer clic sobre Run o usar el atajo del teclado. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/seleccion_para_ejecutar_png.png" align="center" height="150"></a>

¡Ejecutemos el código y veamos qué pasa!

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/codigo_ejecutado.png" align="center" height="250"></a>

Cuando ejecutamos el código de nuestro script esté pasa a la consola. En el caso del primer paquete (`tidyverse`), la consola nos da dos avisos. El primero, cuáles son todos los paquetes que estamos cargando al usar cargar `tidyverse`. Como comentamos antes, este es un metapaquete que incluye otros paquetes en su interior. Al llamarlos a través de `library(tidyverse)` se activan estos 8 paquetes que aparecen consignados (pese a que incluye más) y eso es lo que nos está avisando R en la consola. El otro aviso es de un "Conflicto". Nos dice que las funciones `filter()`y `lag()` del paquete `dplyr` tienen el mismo nombre que funciones del paquete `stats` (que es parte de R base). Como cargamos `dplyr`después (al instalar `tidyverse`), lo que R nos avisa es que son las funciones de este paquete las que van a prevalecer por sobre las del paquete `stats`.

#### Buenas prácticas

En este punto es importante sugerir dos buenas prácticas. La primera, es hacer lo que ya hicimos: llamar todos los paquetes que ocuparemos al inicio de nuestro script. De este modo, cuando volvemos a trabajar con él más adelante (u otra persona quiere ejecutarlo) queda claro desde el principio qué paquetes se utilizan (y es necesario descargar). Obviamente, cuando comenzamos a escribir un script no siempre sabemos cuáles son todos los paquetes que necesitaremos. Por eso, si en la mitad del proceso decido usar un nuevo paquete, la buena práctica es  volver a las primeras líneas del script y agregarlo. 

La segunda buena práctica es comentar nuestro script. En R podemos agregar comentarios anteponiendo un `#` al fragmento que cumple esa función. En una línea de nuestro script, todo lo que está después de un `#` no se ejecuta como código. 

¿Por qué es importante comentar nuestro script? Porque así podemos recordar qué es lo que un determinado fragmento de código hace o dejar registro de por qué hicimos algo de una determinada manera. Esto es muy útil para que nuestro futuro yo o las personas con las que compartiremos nuestro script entiendan lo que hicimos. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/comentarios.png" align="center" height="200"></a>

También es útil agregar al inicio de nuestro script una descripción de lo que hace. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/comentario_inicio_script.png" align="center" height="200"></a>

Si te fijas, nuestro script aún dice Untitled1. Antes de seguir, es importante que lo guardemos. Al hacerlo, aparecerá en la pestaña _Files_.  

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/guardar_script.png" align="center" height="200"></a>

## Una mirada inicial a los datos

`babynames` es un paquete que contiene datos sobre nombres registrados en Estados Unidos entre los años 1880 y 2015. El "objeto" que contiene los datos dentro del paquete se llama también `babynames`. No vemos ese objeto en nuestro `Global Environment` porque no lo hemos creado nosotros. Sin embargo, si hacemos clic sobre Global Environment podemos acceder al "environment" de todos los paquetes. En el de `babynames` lo encontraremos: 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/entorno_babynames.png" height="200"></a>

En R, podemos ver un objeto simplemente ejecutándolo. Es decir, escribimos el nombre del objeto y ejecutamos el código. 

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/ejecutar_babynames.png" height="200"></a>

De ahora en adelante, en vez de mostrarte un pantallazo del script, el código que haya que ejecutar aparecerá en un recuadro, así:

```r
babynames
```
<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/objeto_babynames.png" height="300"></a>

En este caso, el objeto `babynames` es una `tibble`, que es un tipo particular de conjunto de datos. No nos detendremos aún en los tipos de objetos que existen en R; lo importante por ahora es saber que R nos muestra en la consola las primeras diez filas para que nos hagamos una idea de lo que contiene y no los casi dos millones que tiene (mejor así, ¿no?).

Si quisiéramos tener una visión general de los datos, hay una función que resulta muy útil para esto, ya que nos los muestra en una pestaña distinta y con un formato tipo planilla: `View()`. 

``` r
View(babynames)
```
Si ejecutas ese código, una nueva pestaña se abrirá y te mostrará todos los datos en un formato tipo planilla:

![](https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/babynames.png)

Existen otras funciones útiles para darle una primera mirada a nuestros datos: `head()` y `tail()`. Como su nombre lo indica, lo que hacen es mostrarnos las primeras y las últimas líneas de nuestros datos, respectivamente. 

``` r
head(babynames)
```
<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/head_babynames.png" height="230"></a>

``` r
tail(babynames)
```

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/tail_babynames.png" height="200"></a>


Las funciones `tail` y `head` resultan muy útiles para chequear si nuestros datos están completos, ya que nos permiten mirar sus extremos.

Si queremos conocer la estructura de nuestro conjunto de datos, es decir, conocer la cantidad de observaciones, de variables y de qué tipo son, podemos utilizar  `str()`.

```r
str(babynames)
```

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/str_babynames.png" height="150"></a>


#### Algo más sobre las funciones

Hasta el momento hemos utilizado funciones en las que hemos indicado un solo "argumento": el nombre del objeto que queremos ver. Sin embargo, todas estas funciones tienen más argumentos. Lo que ha ocurrido es que hemos utilizado los valores que vienen por defecto. Si queremos conocer cuáles son los otros argumentos que acepta, podemos buscar por el nombre de la función en el panel _Help_ o directamente tecleando en la consola: `?función`, por ejemplo:
```r
?tail
```
Si revisamos la ayuda podemos enterarnos que `tail` permite definir la cantidad de filas se muestren. Si en vez de las 6 líneas por defecto quiero que me aparezcan 10, tendría que indicarlo así:

```r
tail(babynames, n = 10)
```

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/tail_babynames_n10.png" align="center" height="250"></a>


Las funciones leen sus argumentos en orden, por lo que si en la ayuda vemos que el segundo argumento de `tail` es `n =`, podríamos solo escribir el número de líneas que queremos, es decir, así:

```r
tail(babynames, 10)
```
<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/tail_babynames_10.png" align="center" height="250"></a>


¡El resultado es el mismo! 


## Exploración y manipulación de los datos

Ahora que ya dimos una mirada inicial al conjunto de datos con el que estamos trabajando, podemos empezar a explorarlo y hacernos preguntas. Por ejemplo, podríamos querer saber a cuántas personas le han puesto como nombre 'Danerys' (como el personaje de Juego de Tronos). Para eso podemos utilizar el siguiente código:

```r
babynames %>% 
    filter(name == "Daenerys")
```

¿Qué hace este código? Le estamos diciendo a R que :
* tome el objeto `babynames` 
* luego (` %>% `) 
* que filtre (`filter()`) los nombres (`name`) que sean iguales `==` a `Daenerys`. 

Si lo ejecutamos, podemos ver el siguiente resultado:

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/filter_daenerys.png" align="center" height="160"></a>

¡Las primeras Daenerys aparecen en 2012! ¿Por qué utilizamos `==` y no `=`? Utilizamos `==` porque lo que le estamos pidiendo es que compruebe que el valor que tome la variable `name` sea igual a "Daenerys". En R (y en otros lenguajes de programación) el signo `=` se utiliza para asignar valores, es decir, cuando queremos, por ejemplo, asignarle un valor a una detemrinada variable (¡lo haremos más adelante!).

Podemos seguir utilizando ese mismo código para buscar otros nombres. Solo tenemos que cambiar el valor que queremos que tenga la variable `name`. Por ejemplo, podríamos continuar el ejemplo y buscar otros personajes de Juego de Tronos:
```r
babynames %>% 
    filter(name == "Sansa")
```
<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/sansas.png" align="center" height="260"></a>

Al parecer Sansa no ha sido un nombre tan popular. Al menos no hasta 2015. ¿Y Arya?

```r
babynames %>% 
    filter(name == "Arya")
```
<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/filter_arya.png" align="center" height="260"></a>

Hay muchas más Aryas. Y aparecen antes (o sea, por influencia del libro y no de la serie, como en los otros dos casos). Y hay tantas Aryas que no alcanzan a imprimirse en la consola. ¿Cómo podríamos saber cuántas son? 

Antes de responder eso, hablemos un poco del símbolo ` %>% `. ¿Qué es ` %>% `? Este símbolo se llama _pipe_ (_tubo_ en inglés) y en el código lo podemos leer como "luego" o "a continuación". El atajo del teclado para realizarlo es `control` + `shift` + `m` (Linux / Windows) o `command` + `shift` + `m` (Mac.)

`%>%`es una función que nos permite encadenar las acciones que queremos aplicar en un objeto (en este caso, `babynames`). Por ejemplo, si quisiéramos saber a cuántas personas le han puesto el nombre Arya, podría agregar otra función que sume todos los valores de la columna `n` (la que tiene la cantidad de nombres por año). La función que nos sirve para eso es `summarize` (o `summarise`; R acepta inglés norteamericano o británico). Como su nombre lo indica, lo que hace `summarize`es resumir información, según el criterio que le entreguemos. Veamos cómo funciona:

```r
babynames %>% 
    filter(name == "Arya") %>% 
    summarize(sum(n))
```
Con este código le estamos diciendo a R que :

* tome el objeto `babynames` 
* luego (` %>% `) 
* que filtre los nombres que sean iguales a Arya (filter == "Arya")
* luego (` %>% `)
* que resuma (`summarize`) la siguiente información:
* la suma (`sum`) de los valores de la columna `n`. 

¿Qué pasa si ejecutamos este código? ¡8866 Aryas!

Para que quede más claro por qué decimos que `summarize` resume, agreguemos otros criterios: que nos de el promedio de Aryas por año (`mean`) y cuándo apareció la primera (`first`).

```r
babynames %>% 
    filter(name == "Arya") %>% 
    summarize(sum(n), mean(n), first(year))
```
<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/summarize_arya.png" align="center" height="260"></a>

Lo que hizo `summarize` fue resumir toda la información que le pedimos en una tabla. Ojo: es probable que la cantidad de decimales que te aparecen a ti sea distinta. Depende de la configuración de cada equipo. 

#### Distintos tipos de sintaxis

Más arriba comentamos que el Tidyverse era un conjunto de paquetes que compartía un mismo enfoque de trabajo con los datos. Uno de las características de este enfoque tiene que ver con la forma de escribir el código. En particular, con cómo cambia la sintaxis del código al usar ` %>% `. Lo que hace esta función es "desempaquetar" el código, de modo que lo leamos de arriba hacia abajo y de izquierda a derecha (la orientación que suele tener nuestra lectura). Por ejemplo, si quisiéramos contar la cantidad de Aryas usando la sintaxis "tradicional" (la de R base) nuestro código se vería así:

```r
sum(babynames$n[babynames$name == "Arya"])
```
Ambos códigos hacen exactamente lo mismo y llegan al mismo resultado: 8866 (puedes probar ejecutándolo). La diferencia es que el primero que escribimos (usando ` %>% `) resulta más fácil de leer que el segundo, en que tenemos que leer de adentro hacia afuera. Además, para facilitar la lectura, los paquetes del Tidyverse suelen tener nombres de funciones que resultan más intuitivas (en inglés, claro).
Existen algunos tipos de análisis estadísticos para los que no es posible aplicar este tipo de sintaxis o situaciones en las que, por un tema de procesamiento, resulta más rápido usar la de R base. 

#### Creación de objetos

Hasta el momento hemos realizado una serie de acciones sobre el objeto `babynames`: hemos filtrado información y hemos hecho cálculos en una variable. Sin embargo, el objeto no ha sido alterado. Si vuelves imprimir en la consola el contenido de ese objeto, tendrás los mismos resultados que al principio, ya que todas las acciones que hemos realizado no han sido guardadas, sino que las hemos hecho en la memoria operativa.

```r
babynames
```
<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/objeto_babynames.png" height="300"></a>

Imagina que nos interesa guardar los datos sobre la cantidad de Aryas porque seguiremos trabajando con ellos y el resto no nos interesa. Para no tener que filtrar cada vez que los queramos ocupar, nos conviene crear un nuevo objeto. En R eso lo hacemos con el símbolo de asignación: `<-`. ¿Cómo funciona? Lo que está a la izquierda del símbolo de asignación es el objeto que queremos crear y lo que está a su derecha es el valor que queremos asignarle. Así:

```r
aryas <- babynames %>% 
    filter(name == "Arya")
```
El código crea un nuevo objeto llamado `aryas`, que contiene lo que resulta de aplicar un filtro a `babynames`. Si ejecutas ese código, no aparecerá nada nuevo en la consola (solo el código que acabas de ejecutar). Sin embargo, en nuestro _Global Enviroment_ (el panel de arriba a la derecha) aparecerá el objeto que hemos creado:

<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/aryas.png" align="center" height="100"></a>

Ahora podemos llamar a ese objeto tal como hicimos con `babynames`. 

```r
aryas
```
<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/objeto_aryas.png" align="center" height="100"></a>

Hacer clic sobre cualquier objeto del _Global Environmet_ es equivalente a aplicar la función `View()`. Haz la prueba: si haces clic sobre `aryas`, se abrirá una nueva pestaña en el panel de tu script en el que verás el objeto como una planilla. En la consola, apareció automáticamente el código para realizar esa acción `View(aryas)`.

## Más funciones para explorar y manipular datos

Trabajemos ahora con el paquete `gapminder`. Este paquete contiene una parte de los datos de Gapminder, una base de datos que incluye información mundial sobre población, expectativa de vida, PIB per cápita y otros. Su autor, Hans Rosling, ha hecho varias charlas TED en las que comenta cosas sobre estos datos que vale la pena mirar.

Podemos dar una mirada inicial a los datos usando las funciones que ya revisamos:

```r
str(gapminder)
head(gapminder)
tail(gapminder)
```
Además, puedes buscar ayuda sobre este paquete y así tener más información sobre cada variables:

```r
?gapminder
```

Las variables que tenemos son país (`country`), continente (`continent`), año (`year`), expectativa de vida (`lifeExp`), población (`pop`) e ingreso percápita en dólares (`gdpPercap`). Otra forma de conocer los nombres de las variables de un conjunto de datos es a través de la función `names()`:
```r
names(gapminder)
```
<a href="url"><img src="https://github.com/rivaquiroga/RLadies-Santiago/blob/master/images/names_gapminder.png" align="center" height="100"></a>


